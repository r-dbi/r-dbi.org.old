<?xml version="1.0" encoding="UTF-8"?>
<rss  xmlns:atom="http://www.w3.org/2005/Atom" 
      xmlns:media="http://search.yahoo.com/mrss/" 
      xmlns:content="http://purl.org/rss/1.0/modules/content/" 
      xmlns:dc="http://purl.org/dc/elements/1.1/" 
      version="2.0">
<channel>
<title>R-DBI</title>
<link>https://maelle.github.io/rdbidotorg/blog/index.html</link>
<atom:link href="https://maelle.github.io/rdbidotorg/blog/index.xml" rel="self" type="application/rss+xml"/>
<description>R + databases</description>
<generator>quarto-1.3.433</generator>
<lastBuildDate>Tue, 21 Dec 2021 00:00:00 GMT</lastBuildDate>
<item>
  <title>Maintaining DBI, 4/4</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-4.html</link>
  <description><![CDATA[ 



<!-- how do you want to pluralize abbreviations? DBMSes, DBMS's DBMSs? -->
<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>The {DBI} package (<strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface) provides an abstraction for communication between R and database management systems (DBMSes) by specifying a common application programming interface (API). Actual connectivity to DBMSes is established via database specific <a href="https://github.com/r-dbi/backends#readme">backend packages</a>, implementing this interface. Examples for such backends include <a href="https://rpostgres.r-dbi.org/">RPostgres</a>, <a href="https://rmariadb.r-dbi.org/">RMariaDB</a>, and <a href="https://rsqlite.r-dbi.org/">RSQLite</a>. For users that are new to DBI, the <a href="https://dbi.r-dbi.org/articles/dbi">introductory tutorial</a> provides a good entry point for getting acquainted with some key concepts.</p>
<p>This blog post summarizes recent developments in {DBI} and related packages and concludes with an outlook on potential future directions. Similar articles are available from previous years, reporting on earlier states of the {DBI} ecosystem:</p>
<ul>
<li><a href="https://www.r-dbi.org/blog/dbi-3-3/">3/4: January 2021</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-2/">2/4: December 2019</a></li>
<li><a href="https://www.r-dbi.org/blog/dbi-3-1/">1/4: December 2018</a></li>
</ul>
</section>
<section id="recent-developments" class="level2">
<h2 class="anchored" data-anchor-id="recent-developments">Recent developments</h2>
<p>Several packages associated with DBI have been updated since <a href="https://www.r-dbi.org/blog/dbi-3-3/">early 2021</a>:</p>
<ul>
<li>DBI 1.1.1 -&gt; 1.1.2 (<a href="https://dbi.r-dbi.org/news/">NEWS</a>)</li>
<li>RMariaDB 1.1.0 -&gt; 1.2.1 (<a href="https://rmariadb.r-dbi.org/news/">NEWS</a>)</li>
<li>RPostgres 1.3.1 -&gt; 1.4.3 (<a href="https://rpostgres.r-dbi.org/news/">NEWS</a>)</li>
<li>RSQLite 2.2.2 -&gt; 2.2.9 (<a href="https://rsqlite.r-dbi.org/news/">NEWS</a>)</li>
<li>DBItest 1.7.0 -&gt; 1.7.2 (<a href="https://dbitest.r-dbi.org/news/">NEWS</a>)</li>
</ul>
<p>And the following sections elaborate on some of the noteworthy changes and improvements contained in these updates, both user-visible and internal.</p>
<section id="clickable-method-documentation" class="level3">
<h3 class="anchored" data-anchor-id="clickable-method-documentation">Clickable method documentation</h3>
<p>The DBI method reference on <a href="https://dbi.r-dbi.org/reference/" class="uri">https://dbi.r-dbi.org/reference/</a> has been updated to include clickable links to known DBI backends. This makes documentation specific to certain backends more accessible, as optional function arguments used by some backend implementations are only documented by the respective packages.</p>
</section>
<section id="full-support-for-aws-redshift" class="level3">
<h3 class="anchored" data-anchor-id="full-support-for-aws-redshift">Full support for AWS Redshift</h3>
<p>Redshift support has been greatly improved by Adam Foryś as part of the RPostgres package and both databases now pass all applicable tests offered by DBItest. The BLOB data type is currently not supported by Redshift and consequently, related tests are skipped. For connecting to a Redshift cluster, the RPostgres package exports <code>Redshift()</code> (to be used over <code>Postgres()</code>).</p>
</section>
<section id="faster-table-imports" class="level3">
<h3 class="anchored" data-anchor-id="faster-table-imports">Faster table imports</h3>
<p>Previous versions of {RMariaDB} and {RPostgres} relied <code>dbBind()</code> for writing tables, using a prepared <code>INSERT INTO ... VALUES (...)</code> statement with placeholders. Contrary to the expectation, this was very inefficient, because each row requires a communication roundtrip to the server. To improve the situation, {RMariaDB} now uses <code>LOAD DATA LOCAL INFILE</code> to load data from a temporary CSV file. Recent MySQL server versions disable this capability by default, and therefore it is also disabled by default in {RMariaDB}. If your server supports this, enable fast loading by passing <code>load_data_local_infile = TRUE</code> to <code>dbConnect()</code>. For {RPostgres}, <code>dbAppendTable()</code> has been updated to use the same optimization as <code>dbWriteTable()</code> when writing data.</p>
</section>
<section id="windows-compatibility" class="level3">
<h3 class="anchored" data-anchor-id="windows-compatibility">Windows compatibility</h3>
<p>{RMariaDB} can now use the <code>caching_sha2_password</code> plugin on Windows which was permanently disabled on previous versions. This is important for connecting to recent versions of MySQL which require this plugin.</p>
</section>
<section id="extended-data-types-for-sqlite" class="level3">
<h3 class="anchored" data-anchor-id="extended-data-types-for-sqlite">Extended data types for SQLite</h3>
<p>Thanks to Eric Anderson, {RSQLite} now returns typed data for columns declared with <code>DATE</code>, <code>TIME</code> and <code>TIMESTAMP</code> data types. To enable this feature, <code>extended_types = TRUE</code> has to be passed in <code>dbConnect()</code>.</p>
</section>
<section id="interrupt-handling" class="level3">
<h3 class="anchored" data-anchor-id="interrupt-handling">Interrupt handling</h3>
<p>The <code>check_interrupts = TRUE</code> argument to <code>dbConnect()</code> in {RPostgres} now correctly cancels the query and returns to the user as soon as an interrupt is signalled (by pressing Ctrl+C or Escape in RStudio). Thanks to Mateusz Żółtak for tests and discussion.</p>
</section>
<section id="automation" class="level3">
<h3 class="anchored" data-anchor-id="automation">Automation</h3>
<p>{RMariaDB} is tested against all combinations of major MariaDB and MySQL client/server releases, while {RPostgres} is tested against all versions of PostgreSQL ≥ 10 using GitHub Actions. This guarantees compatibility with a broader range of database instances for both backends and for future updates to the corresponding packages. All tests are run daily, thereby ensuring that upstream updates remain compatible with backend implementations. The database servers are installed on GitHub Actions using dedicated actions for installing <a href="https://github.com/ankane/setup-mariadb/">MariaDB</a>, <a href="https://github.com/ankane/setup-mysql">MySQL</a> and <a href="https://github.com/ankane/setup-postgres">Postgres</a>, maintained by Andrew Kane.</p>
<p>Thanks to the automated monitoring of SQLite3 releases, the vendored code can be updated continuously with minimal delay over upstream releases. {RSQLite} now uses SQLite3 3.37.0 and became available from CRAN only 10 days after the upstream release.</p>
</section>
<section id="simpler-upgrade-path-for-dbitest" class="level3">
<h3 class="anchored" data-anchor-id="simpler-upgrade-path-for-dbitest">Simpler upgrade path for DBItest</h3>
<p>By making it possible for backends to specify the supported version of {DBItest}, using <code>tweaks(dbitest_version = "x.y.z")</code>, it is now simpler to update {DBItest} on CRAN. Newly added tests in {DBItest} are skipped if the declared version is too low. Skipped tests are reported in the test results and can be fixed independently of the {DBItest} releases.</p>
</section>
<section id="inlined-boost-headers" class="level3">
<h3 class="anchored" data-anchor-id="inlined-boost-headers">Inlined Boost headers</h3>
<p>The {BH} package is a C++ header-only package containing in excess of 10,000 individual files and installation has proven challenging for some systems, such as Amazon’s Elastic File System. By vendoring only the required files into {RSQLite}, {RMariaDB} and {RPostgres}, it is no longer necessary to install {BH} to use these packages, and therefore the total number of files required to build these packages is greatly reduced. Thanks to RStudio for supporting this change.</p>
</section>
<section id="reorganized-structure-of-the-r-code" class="level3">
<h3 class="anchored" data-anchor-id="reorganized-structure-of-the-r-code">Reorganized structure of the R code</h3>
<p>{DBI} uses S4 classes and generic functions to specify the interface to be implemented by backends, using database specific subclasses. Class specific generic implementations are consequently declared with <code>setMethod()</code>, using the following convention:</p>
<div class="sourceCode" id="cb1" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">setMethod</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"foo"</span>, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myclass"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"character"</span>), <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">function</span>(x, char_arg, ...) {</span>
<span id="cb1-2">  ...</span>
<span id="cb1-3">})</span></code></pre></div>
<p>Instead of passing an anonymous function as <code>definition</code> argument to <code>setMethod()</code>, this has been changed to a semantic equivalent which is more explicit:</p>
<div class="sourceCode" id="cb2" style="background: #f1f3f5;"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1">foo_myclass_character <span class="ot" style="color: #003B4F;
background-color: null;
font-style: inherit;">&lt;-</span> <span class="cf" style="color: #003B4F;
background-color: null;
font-style: inherit;">function</span>(x, char_arg, ...) {</span>
<span id="cb2-2">  ...</span>
<span id="cb2-3">}</span>
<span id="cb2-4"></span>
<span id="cb2-5"><span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">setMethod</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"foo"</span>, <span class="fu" style="color: #4758AB;
background-color: null;
font-style: inherit;">c</span>(<span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"myclass"</span>, <span class="st" style="color: #20794D;
background-color: null;
font-style: inherit;">"character"</span>), foo_myclass_mycharacter)</span></code></pre></div>
<p>Reasons for this transformation were to make the respective implementations more accessible, as function definitions now can be displayed more easily via <code>mypkg:::foo_myclass_character</code>, and to generally make the code-base easier to read and navigate. In similar spirit, each such generic implementation is now defined in its own file with file names constructed as <code>foo_myclass_mycharacter.R</code>. This makes it immediately clear, exactly which methods are implemented by a package, simply from the list of associated files. Code transformation was carried out in semi-automated fashion, with the help of a <a href="https://github.com/pre-processing-r/rpp/blob/main/script/un-s4.R">script</a> that uses infrastructure from the “Pre-processing R code” project.</p>
</section>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future work</h2>
<p>The {DBI} package provides a low-level interface for database connectivity with a <a href="https://www.r-dbi.org/blog/dbi-3-3/">narrow scope</a>. Data query and manipulation tasks that are not in-scope for {DBI} are currently left to auxiliary packages, including <a href="https://dbplyr.tidyverse.org/">dbplyr</a>, <a href="https://cynkra.github.io/dm/">dm</a>, <a href="https://github.com/ankane/dbx">dbx</a> and <a href="https://winvector.github.io/rquery/">rquery</a>. {DBI} uses S4, one of several systems for object-oriented programming in R. While S4 offers several advantages over its predecessor S3, including increased strictness and multiple dispatch, it also is more rigid compared to S3. <!-- I don't see how this is specific to S4, but then again, I haven't really used S4 myself, so I'm no expert; it might still be worthwhile to elaborate a bit here --> <!-- also, what is the intention of discussing S4 here? is it to justify a move away from S4? if so I feel a need for fleshing out this argument more --> Consequently, once the definition of a generic is published, it is difficult to make changes without breaking downstream dependencies.</p>
<p>The first release of {DBI} dates back roughly 20 years and since, the package has been widely adopted by others, both for accessing databases or providing <a href="https://github.com/r-dbi/backends#readme">backends</a> to DBMSes. Its success, combined with the rigidity imposed by S4, has made it difficult to extend the interface beyond what is currently offered. When considering new additions, there is pressure to get it right in the first attempt, thereby holding back less essential improvements.</p>
<p>The DBI specification in the {DBItest} package aims to standardize the feature set of {DBI}-compliant backends, and to provide a test suite against which conformity of an implementation can be verified. Due to differences in design of individual DBMSes, not all features of the DBI specification and therefore not all tests provided by {DBItest} are supported by all backend packages. Using a newly introduced mechanism, backends can declare, by means of <em>tweaks</em>, which tests to run in what way. This addresses some of the problems associated with implementing a test suite that can be re-used for several backends. General-purpose clients however, can only make guesses as to the exact feature set supported by a given backend or connection. There currently is no formal way to declare certain capabilities as missing (or available).</p>
<p>Based on these observations, for extending DBI, it may be worthwhile to address the following two issues:</p>
<ol type="1">
<li>Formal declaration of capabilities.</li>
<li>Decoupling the user from the backend interface.</li>
</ol>
<p>The new <a href="https://github.com/r-dbi/dbi3">dbi3 repository</a> contains a collection of issues, some of which will be easier to address after these changes are in place.</p>
<section id="capabilities" class="level3">
<h3 class="anchored" data-anchor-id="capabilities">Capabilities</h3>
<p>A mechanism is introduced by which backends can declare explicitly which features of DBI a particular connection supports. Examples for existing functionality that varies over backends include:</p>
<ul>
<li>Support for BLOBs (not available e.g.&nbsp;in Redshift).</li>
<li>Support for logical columns (not available e.g.&nbsp;in SQL Server or SQLite).</li>
<li>Support for named or nested transactions (not standardized).</li>
<li>Placeholder character to use in parameterized queries (different across databases).</li>
</ul>
<p>In the future, backends may also indicate:</p>
<ul>
<li>Whether asynchronous queries are supported (important for web development).</li>
<li>Whether the database supports SQL or a different query language (DBI currently assumes SQL).</li>
</ul>
<p>The list of possible capabilities will be maintained by DBI and {DBItest} will rely solely on these capabilities, foregoing the current <em>tweaking</em> mechanism. Users can in turn query these capabilities and act accordingly.</p>
</section>
<section id="separate-user-interface" class="level3">
<h3 class="anchored" data-anchor-id="separate-user-interface">Separate user interface</h3>
<p>As an evolution of the current approach, where users of DBI will often directly call methods that are mostly implemented by backends themselves, introduction of a separate user-facing API may be worthwhile. Based on plain functions and essentially providing a <a href="https://en.wikipedia.org/wiki/Facade_pattern">facade</a>, this user interface would be sufficient for the overwhelming majority of use cases. At the same time, such an approach should contribute to simpler code with less duplication in backend packages.</p>
<p>The new user interface performs tasks that are common to all database backends (e.g.&nbsp;validation of arguments), and calls methods provided by the backends, in some cases dependent on declared capabilities. Overall, this should lead to less code that needs to be reimplemented across backends. The decoupling of interfaces could help with iterative improvements, while guaranteeing stability for users. As an example, a <code>dbi_write_table()</code> function that optionally creates and writes data to a database table might encompass the following functionality:</p>
<ul>
<li>If the backend supports transactions:
<ul>
<li>Call <code>dbi_is_transacting()</code> to determine if the statement is occurring as part of a transaction.</li>
<li>Call <code>dbi_begin_transaction()</code> if it is not already part a transaction.</li>
<li>Use <code>dbi_begin_transaction(name = "...")</code> if the backend supports named transactions.</li>
</ul></li>
<li>Call <code>dbi_remove_table()</code> and/or <code>dbi_create_table()</code> if necessary.</li>
<li>Call <code>dbi_append_table()</code>.</li>
<li>Call <code>dbi_commit()</code> on success or <code>dbi_rollback()</code> on failure whenever transactions are supported.</li>
</ul>
<p>For appending rows to a table, <code>dbi_append_table()</code> might check if the backend supports streaming uploads or if SQL should be created for inserting rows. In the latter case, the SQL statement (or multiple statements for large tables) could be constructed using quoted literals obtained from <code>dbi_quote_literal()</code>. The backend could indicate the maximum supported length of a statement, so that splitting of large tables into multiple chunks can happen automatically.</p>
<p>As a final example, a backend supporting asynchronous operations might rely entirely on DBI for providing the corresponding blocking operations. The asynchronous procedure provided by the backend could automatically be wrapped by a DBI function that only returns upon completion.</p>
<p>Such a split API would allow for generics declared by {DBI} for interfacing with backends to remain frozen. To extend or alter the signature of a generic, a new generic can be added, using some form of versioning (e.g.&nbsp;with a numeric suffix, such as <code>dbAppendTable1()</code>, <code>dbAppendTable2()</code>, etc.). With such an architecture, arguments in generics could be declared explicitly, without relying on forwarding via <code>...</code>, as is done currently. The user is presented with a stable API with only backward-compatible changes, {DBI} internally decides which versions of a method to call. When a new version of a generic is introduced, {DBI} documents and proposes an upgrade path for backend implementers. In the long run this would also allow for transitioning to another object-oriented system such as S3 or <a href="https://github.com/RConsortium/OOP-WG/">R7</a> without introducing user-facing breaking changes.</p>
<p>This approach also enables support of rich callbacks: each function in the facade can notify listeners on entry and before returning. For example, a call to <code>dbi_connect()</code> would notify interested parties that a new connection has been established, and a call to <code>dbi_query()</code> issues callbacks with the query and the result. Potential use cases include:</p>
<ul>
<li>Logging as in {dblog}.</li>
<li>The <em>Connections</em> pane in RStudio.</li>
<li>Mocking (with hooks) as in {dittodb}.</li>
</ul>
<p>A versioning scheme could also be implemented for callbacks, keeping existing callbacks frozen while allowing for addition of new features that alter callback signatures.</p>
</section>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I’d like to thank Jeroen Ooms and Gábor Csárdi for providing crucial infrastructure to support this and many other projects in the R ecosystem.</p>
<p>Thanks to the numerous contributors to the packages in the “Maintaining DBI” project in 2021:</p>
<ul>
<li>DBI: <a href="https://github.com/bwohl">@bwohl</a>, <a href="https://github.com/cboettig">@cboettig</a>, <a href="https://github.com/dcassol">@dcassol</a>, <a href="https://github.com/jawond">@jawond</a>, <a href="https://github.com/mmccarthy404">@mmccarthy404</a>, <a href="https://github.com/pnacht">@pnacht</a>, <a href="https://github.com/r2evans">@r2evans</a>, <a href="https://github.com/vituri">@vituri</a>, and <a href="https://github.com/zoushucai">@zoushucai</a>;</li>
<li>RSQLite: <a href="https://github.com/ablack3">@ablack3</a>, <a href="https://github.com/billy34">@billy34</a>, <a href="https://github.com/edwindj">@edwindj</a>, <a href="https://github.com/gaborcsardi">@gaborcsardi</a>, <a href="https://github.com/ggrothendieck">@ggrothendieck</a>, <a href="https://github.com/giocomai">@giocomai</a>, <a href="https://github.com/habilzare">@habilzare</a>, <a href="https://github.com/honghh2018">@honghh2018</a>, <a href="https://github.com/Jeff-Gui">@Jeff-Gui</a>, <a href="https://github.com/kevinushey">@kevinushey</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/plantton">@plantton</a>, <a href="https://github.com/schuemie">@schuemie</a>, <a href="https://github.com/Shicheng-Guo">@Shicheng-Guo</a>, and <a href="https://github.com/tschoonj">@tschoonj</a>;</li>
<li>RPostgres: <a href="https://github.com/aleaficionado">@aleaficionado</a>, <a href="https://github.com/armenic">@armenic</a>, <a href="https://github.com/ateucher">@ateucher</a>, <a href="https://github.com/baderstine">@baderstine</a>, <a href="https://github.com/beralef">@beralef</a>, <a href="https://github.com/carlganz">@carlganz</a>, <a href="https://github.com/ColinFay">@ColinFay</a>, <a href="https://github.com/dcaud">@dcaud</a>, <a href="https://github.com/dpprdan">@dpprdan</a>, <a href="https://github.com/f-ritter">@f-ritter</a>, <a href="https://github.com/galachad">@galachad</a>, <a href="https://github.com/GitHubGeniusOverlord">@GitHubGeniusOverlord</a>, <a href="https://github.com/gontcharovd">@gontcharovd</a>, <a href="https://github.com/gtm19">@gtm19</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/jakob-r">@jakob-r</a>, <a href="https://github.com/jeroen">@jeroen</a>, <a href="https://github.com/jkylearmstrong">@jkylearmstrong</a>, <a href="https://github.com/JSchoenbachler">@JSchoenbachler</a>, <a href="https://github.com/matthewgson">@matthewgson</a>, <a href="https://github.com/mgirlich">@mgirlich</a>, <a href="https://github.com/mmuurr">@mmuurr</a>, <a href="https://github.com/mskyttner">@mskyttner</a>, <a href="https://github.com/phedinkus">@phedinkus</a>, <a href="https://github.com/ppssphysics">@ppssphysics</a>, <a href="https://github.com/RakeshG1">@RakeshG1</a>, <a href="https://github.com/rickbpdq">@rickbpdq</a>, <a href="https://github.com/samiaab1990">@samiaab1990</a>, <a href="https://github.com/sawnaanwas">@sawnaanwas</a>, <a href="https://github.com/tomasjanikds">@tomasjanikds</a>, <a href="https://github.com/vspinu">@vspinu</a>, <a href="https://github.com/waynelapierre">@waynelapierre</a>, <a href="https://github.com/zmbc">@zmbc</a>, and <a href="https://github.com/zozlak">@zozlak</a>;</li>
<li>RMariaDB: <a href="https://github.com/bakiunal">@bakiunal</a>, <a href="https://github.com/dirkschumacher">@dirkschumacher</a>, <a href="https://github.com/hadley">@hadley</a>, <a href="https://github.com/jeroen">@jeroen</a>, <a href="https://github.com/Mosk915">@Mosk915</a>, <a href="https://github.com/noamross">@noamross</a>, <a href="https://github.com/paulmaunders">@paulmaunders</a>, <a href="https://github.com/retowyss">@retowyss</a>, <a href="https://github.com/rorynolan">@rorynolan</a>, <a href="https://github.com/twentytitus">@twentytitus</a>, <a href="https://github.com/verajosemanuel">@verajosemanuel</a>, <a href="https://github.com/wiligl">@wiligl</a>, <a href="https://github.com/Woosah">@Woosah</a>, and <a href="https://github.com/zoushucai">@zoushucai</a>.</li>
<li>DBItest: <a href="https://github.com/adamsma">@adamsma</a>, and <a href="https://github.com/michaelquinn32">@michaelquinn32</a>;</li>
</ul>
<p>Thanks also to Nicolas Bennett for reviewing and editing this blog post.</p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-4.html</guid>
  <pubDate>Tue, 21 Dec 2021 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 3/4</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-3.html</link>
  <description><![CDATA[ 



<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>DBI stands for <strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface. The DBI package connects R to database management systems (DBMS). The goal of DBI is to provide a common interface for database access, regardless of the specific underlying DBMS. DBI works with a variety of DBMS, such as Postgres, MariaDB, and SQLite, through dedicated <a href="https://github.com/r-dbi/backends#readme">backend packages</a>. For first-time users I recommend starting with the new <a href="https://dbi.r-dbi.org/articles/dbi">introductory tutorial</a>.</p>
<p>The current version of DBI is 1.1.1. This blog post attempts to define the scope of the DBI project, summarizes recent developments in DBI and related packages, and showcases future work.</p>
</section>
<section id="scope-of-the-dbi-project" class="level2">
<h2 class="anchored" data-anchor-id="scope-of-the-dbi-project">Scope of the DBI project</h2>
<p>The DBI package is perfect for anyone looking to connect to a database, read/write entire tables, and/or execute SQL queries. DBI gives a direct access to the database driver, leaving more sophisticated data query and manipulation tasks to packages like <a href="https://dbplyr.tidyverse.org/">dbplyr</a>, <a href="https://github.com/ankane/dbx">dbx</a> and <a href="https://winvector.github.io/rquery/">rquery</a>.</p>
<p>The core DBI project in R provides an interface for databases, specified in textual form and via automated tests. The <a href="https://dbi.r-dbi.org/articles/spec">DBI specification</a> contains a detailed description of the methods provided by DBI. In summary, the interface covers:</p>
<ul>
<li><p>Discovery of tables, also in schemas</p></li>
<li><p>Reading/writing/creating/removing tables</p></li>
<li><p>Executing queries, fetching data (with parameters)</p></li>
<li><p>Safe quoting: low-level composition of queries</p></li>
<li><p>Transactions</p></li>
</ul>
<p>DBI should provide a way to ingest data of any type into R, at least in serialized form (e.g.&nbsp;string or <a href="https://en.wikipedia.org/wiki/Binary_large_object">blob</a>). It should offer a robust reliable interface for dependent packages; anything beyond this scope should be left to packages that extend DBI:</p>
<ul>
<li><p>arkdb: archival of database data</p></li>
<li><p>connection: integrate database connections with the RStudio IDE</p></li>
<li><p>dbplyr and rquery: generation of SQL queries</p></li>
<li><p>dbx: DBI extension for data manipulation</p></li>
<li><p>dittodb: mocking for databases</p></li>
<li><p>dm: relational data models (via dbplyr)</p></li>
<li><p>pool: connection pooling</p></li>
<li><p>sqlr: schema definition</p></li>
</ul>
<p>and many more.</p>
</section>
<section id="recent-developments-in-dbi" class="level2">
<h2 class="anchored" data-anchor-id="recent-developments-in-dbi">Recent developments in DBI</h2>
<p>This section discusses:</p>
<ul>
<li><p>the new DBI tutorials,</p></li>
<li><p>improvements for datetime data,</p></li>
<li><p>other notable changes,</p></li>
<li><p>the move to GitHub Actions.</p></li>
</ul>
<p>The first three items directly affect DBI users, the last item much less so. It is nevertheless an important investment in the stability of the DBI infrastructure.</p>
<section id="new-tutorials" class="level3">
<h3 class="anchored" data-anchor-id="new-tutorials">New tutorials</h3>
<p>James Wondrasek substantially expanded the “Introduction to DBI” article and added a second article. DBI now features two tutorials. The <a href="https://dbi.r-dbi.org/articles/dbi">introduction</a> includes a walkthrough that describes connecting and querying a real database. The <a href="https://dbi.r-dbi.org/articles/dbi-advanced">“Advanced DBI usage”</a> tutorial shows more advanced examples of quoting and parameter binding. The tutorials are an important first-hand resource for new users.</p>
</section>
<section id="time-zones" class="level3">
<h3 class="anchored" data-anchor-id="time-zones">Time zones</h3>
<p>To date, it was only possible to work reliably with time zones when the database connection represented all times in UTC. This poses a few problems in practice:</p>
<ul>
<li><p>Not all databases store timestamps as UTC or with time zone offset, often local time is assumed by the data model.</p></li>
<li><p>Other systems often use the default setting for time zone, this harms interoperability of DBI in these cases.</p></li>
<li><p>Conversion of timestamps to dates via the SQL function <code>DATE</code> is only correct when the session time zone is set correctly.</p></li>
</ul>
<p>RMariaDB 1.1.0 and RPostgres 1.3.0 gained more robust support for datetime values. As proposed in the <a href="https://www.r-dbi.org/blog/dbi-3-2/">previous blog post</a>, new arguments <code>timezone</code> and <code>timezone_out</code> were added. Both arguments should use Olson names such as <code>Europe/Berlin</code> or <code>America/New_York</code>, not time offsets like <code>+01:00</code>; the latter may change with daylight time savings season. If <code>timezone</code> is set to <code>NULL</code>, an attempt is made to detect the correct time zone on the database. Thanks to Philipp Schauberger for contributing the initial <code>timezone</code> argument for RMariaDB.</p>
<p>RSQLite does not natively support dates or times. A promising <a href="https://github.com/r-dbi/RSQLite/pull/333">pull request</a> is underway that implements support for treating numeric values as time offsets if the column type is declared in a specific way.</p>
</section>
<section id="notable-changes-to-dbi-backends" class="level3">
<h3 class="anchored" data-anchor-id="notable-changes-to-dbi-backends">Notable changes to DBI backends</h3>
<p>The following package versions were sent to CRAN since the last blog post:</p>
<ul>
<li>DBI 1.1.0 -&gt; 1.1.1 (<a href="https://dbi.r-dbi.org/news/">NEWS</a>)</li>
<li>RMariaDB 1.0.8 -&gt; 1.1.0 (<a href="https://rmariadb.r-dbi.org/news/">NEWS</a>)</li>
<li>RPostgres 1.2.0 -&gt; 1.3.1 (<a href="https://rpostgres.r-dbi.org/news/">NEWS</a>)</li>
<li>RSQLite 2.1.5 -&gt; 2.2.2 (<a href="https://rsqlite.r-dbi.org/news/">NEWS</a>)</li>
</ul>
<p>Highlights are:</p>
<ul>
<li><p>DBI: Two new tutorials; minor improvements to <code>dbQuoteLiteral()</code>, this is relevant for backends that don’t provide their own implementation.</p></li>
<li><p>RMariaDB: Better handling of data types and character encoding; minor tweaks to <code>dbBind()</code> and <code>dbQuoteLiteral()</code>.</p></li>
<li><p>RPostgres: The new <code>Redshift()</code> driver that allows downstream packages to distinguish between Postgres and Amazon RedShift (thanks Hadley Wickham); minor improvements for querying and passing date and time types, <code>postgresWaitForNotify()</code> contributed by Jamie Lentin.</p></li>
<li><p>RSQLite: <code>dbAppendTable()</code> is faster, strings and blobs can have virtually unlimited size (limit 2 GB), embedded SQLite library is now in version 3.34.</p></li>
<li><p>DBItest: understanding which tests failed is now simpler, also thanks to simpler backtraces; <code>test_some()</code> integrates with the dblog package and shows DBI methods called; established compatibility with testthat 3.0.0; better and more robust tests.</p></li>
<li><p>RKazam: Is now a template repository</p></li>
</ul>
<p>Thanks to Jeroen Ooms for maintaining Windows versions for the database libraries.</p>
</section>
<section id="qa-and-automation" class="level3">
<h3 class="anchored" data-anchor-id="qa-and-automation">QA and automation</h3>
<p>Automated tests are a crucial part of modern software engineering. These are often augmented with continuous integration (CI) services that run these tests regularly or with every change to the code. When I started working on DBI, Travis CI offered excellent continuous integration services for open-source repositories. Unfortunately, this is no longer the case: the free tier introduced a limit on CI build time, rendering it effectively unusable for DBI.</p>
<p><a href="https://github.com/features/actions">GitHub Actions</a> is a CI/CD platform tightly integrated with GitHub. It is somewhat simpler to set up, also for creating workflows that e.g.&nbsp;open a pull request. It is sufficient to add a YAML configuration file to a dedicated location in the repository. Each build automatically obtains a token that can be used to interact with the GitHub API. R support is provided by <a href="https://github.com/r-lib/actions">dedicated workflows and actions</a> contributed by RStudio. Check status is conveniently reported in detail with each pull request, and the checks run considerably faster due to higher concurrency.</p>
<p>Continuous integration for all packages in the project has moved to GitHub Actions. Cross-platform checks for all backends on the major operating systems were a bit challenging, because the tests require a live database. Thanks to Andrew Kane for providing GitHub actions that install database engines on all platforms, this greatly simplified the move.</p>
<p>Three more parts of the infrastructure were updated as part of the move:</p>
<ol type="1">
<li><p>The odbc and duckdb packages are now also checked when the DBItest package updates. This ensures that new or amended specifications do not break these packages. If you maintain a DBI backend that uses DBItest, get in touch for integrating your backend with these checks.</p></li>
<li><p>The <a href="https://github.com/r-dbi/backends#readme">list of DBI backends</a> is now continuously updated. Updates to backends are applied automatically. Every time a new backend is found, a pull request is opened.</p></li>
<li><p>A new <a href="https://github.com/r-dbi/RSQLite/pull/337">pull request</a> is opened in RSQLite when a new version of the SQLite library is available. This makes it much easier to keep the bundled SQLite version up to date.</p></li>
</ol>
</section>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future work</h2>
<p>The last blog post already identified major milestones:</p>
<ul>
<li><p>query cancellation</p></li>
<li><p>testing on remote databases</p></li>
</ul>
<p>A triage of the contributed issues has identified the following additional major topics:</p>
<ul>
<li><p><code>immediate</code> argument to <code>dbSendQuery()</code> and <code>dbSendStatement()</code> for RMariaDB and RPostgres</p></li>
<li><p>performance of table import</p></li>
<li><p>reconnect if a database connection is lost</p></li>
</ul>
<p>Other minor issues include:</p>
<ul>
<li><p>SSL connections</p></li>
<li><p>authentication plugins</p></li>
<li><p>support for more data types: arrays, JSON, …</p></li>
</ul>
<p>I’m planning to resolve most of the remaining issues in a final sprint. Some of these issues can be outsourced to other packages, according to the scope outlined in the previous sections, priority should be given to issues that must be resolved in the core packages. Future work might shift towards providing or improving useful extensions.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I’d like to thank James Wondrasek for creating the DBI tutorials and for a review of this blog post, Angelica Becerra for reviewing the material, and the numerous contributors to the packages in the “Maintaining DBI” project (DBI¹, RSQLite², RPostgres³, RMariaDB⁴, and DBItest⁵):</p>
<p><a href="https://github.com/abalter">@abalter</a>³, <a href="https://github.com/alanpaulkwan">@alanpaulkwan</a>², <a href="https://github.com/AllenSuttonValocity">@AllenSuttonValocity</a>³, <a href="https://github.com/altay-oz">@altay-oz</a>³, <a href="https://github.com/anderic1">@anderic1</a>², <a href="https://github.com/andybeet">@andybeet</a>¹, <a href="https://github.com/arencambre">@arencambre</a>⁴, <a href="https://github.com/artemklevtsov">@artemklevtsov</a>³, <a href="https://github.com/bastianilso">@bastianilso</a>⁴, <a href="https://github.com/bczernecki">@bczernecki</a>¹, <a href="https://github.com/Byggvir">@Byggvir</a>⁴, <a href="https://github.com/Chrisjb">@Chrisjb</a>¹, <a href="https://github.com/clementbfeyt">@clementbfeyt</a>⁴, <a href="https://github.com/colearendt">@colearendt</a>¹, <a href="https://github.com/daattali">@daattali</a>¹, <a href="https://github.com/datawookie">@datawookie</a>¹, <a href="https://github.com/dpprdan">@dpprdan</a>³⁵, <a href="https://github.com/elfatherbrown">@elfatherbrown</a>⁴, <a href="https://github.com/EntwicklR">@EntwicklR</a>², <a href="https://github.com/ericemc3">@ericemc3</a>⁴, <a href="https://github.com/formix">@formix</a>³, <a href="https://github.com/fproske">@fproske</a>¹, <a href="https://github.com/georgevbsantiago">@georgevbsantiago</a>¹, <a href="https://github.com/GitHunter0">@GitHunter0</a>¹, <a href="https://github.com/hadley">@hadley</a>²³, <a href="https://github.com/hmeleiro">@hmeleiro</a>¹, <a href="https://github.com/hpages">@hpages</a>², <a href="https://github.com/imlijunda">@imlijunda</a>³, <a href="https://github.com/inferiorhumanorgans">@inferiorhumanorgans</a>³, <a href="https://github.com/jarauh">@jarauh</a>⁴, <a href="https://github.com/jawond">@jawond</a>¹, <a href="https://github.com/jeroen">@jeroen</a>³, <a href="https://github.com/jimhester">@jimhester</a>¹, <a href="https://github.com/jjesusfilho">@jjesusfilho</a>³, <a href="https://github.com/jsilve24">@jsilve24</a>², <a href="https://github.com/kforner">@kforner</a>⁴, <a href="https://github.com/kmishra9">@kmishra9</a>², <a href="https://github.com/Kodiologist">@Kodiologist</a>¹², <a href="https://github.com/LaugeGregers">@LaugeGregers</a>³, <a href="https://github.com/luispuerto">@luispuerto</a>², <a href="https://github.com/martinstuder">@martinstuder</a>⁵, <a href="https://github.com/matteodelucchi">@matteodelucchi</a>⁴, <a href="https://github.com/MaximumV">@MaximumV</a>¹, <a href="https://github.com/mbannert">@mbannert</a>³, <a href="https://github.com/mbedward">@mbedward</a>³, <a href="https://github.com/mgirlich">@mgirlich</a>², <a href="https://github.com/mlamias">@mlamias</a>¹, <a href="https://github.com/mllg">@mllg</a>¹, <a href="https://github.com/mmuurr">@mmuurr</a>³, <a href="https://github.com/momeara">@momeara</a>³, <a href="https://github.com/MonteShaffer">@MonteShaffer</a>⁴, <a href="https://github.com/Mosk915">@Mosk915</a>⁴, <a href="https://github.com/nfultz">@nfultz</a>², <a href="https://github.com/norquanttech">@norquanttech</a>³, <a href="https://github.com/OMalytics">@OMalytics</a>³, <a href="https://github.com/oriolcmp">@oriolcmp</a>⁴, <a href="https://github.com/Osc2wall">@Osc2wall</a>⁴, <a href="https://github.com/psychobas">@psychobas</a>², <a href="https://github.com/randyzwitch">@randyzwitch</a>⁵, <a href="https://github.com/rcfree">@rcfree</a>², <a href="https://github.com/rnorberg">@rnorberg</a>¹, <a href="https://github.com/rodriguesk">@rodriguesk</a>², <a href="https://github.com/rossholmberg">@rossholmberg</a>⁴, <a href="https://github.com/Sahil308">@Sahil308</a>⁴, <a href="https://github.com/samuel-cs4">@samuel-cs4</a>⁴, <a href="https://github.com/schuemie">@schuemie</a>², <a href="https://github.com/shutinet">@shutinet</a>², <a href="https://github.com/splaisan">@splaisan</a>², <a href="https://github.com/Trowic">@Trowic</a>⁴, <a href="https://github.com/verajosemanuel">@verajosemanuel</a>⁴, <a href="https://github.com/VictorYammouni">@VictorYammouni</a>¹, <a href="https://github.com/vigyoyo">@vigyoyo</a>⁴, <a href="https://github.com/vikram-rawat">@vikram-rawat</a>³, <a href="https://github.com/vspinu">@vspinu</a>³, <a href="https://github.com/warnes">@warnes</a>³, <a href="https://github.com/wiligl">@wiligl</a>², <a href="https://github.com/ycphs">@ycphs</a>⁴, and <a href="https://github.com/zyxdef">@zyxdef</a>¹.</p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-3.html</guid>
  <pubDate>Wed, 20 Jan 2021 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 2/4</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-2.html</link>
  <description><![CDATA[ 



<section id="what-is-dbi" class="level2">
<h2 class="anchored" data-anchor-id="what-is-dbi">What is DBI?</h2>
<p>DBI stands for <strong>d</strong>ata<strong>b</strong>ase <strong>i</strong>nterface, and DBI is a package for connecting to database management systems (DBMS). The goal of DBI is to provide a common interface for accessing a database, regardless of the specific underlying DBMS.</p>
<p>DBI works with a variety of DBMS, such as Postgres, MariaDB, and SQLite, allowing users to focus on the specifics of their project instead of setting up the infrastructure for data import and export.</p>
<p>The DBI package is perfect for anyone looking to connect to a database, read/write entire tables, and/or execute SQL queries. DBI offers more control to the user than packages such as <a href="https://dbplyr.tidyverse.org/">{dbplyr}</a>.</p>
<p>The current version of DBI is 1.1.0. This blog post summarizes recent developments in DBI and related packages.</p>
</section>
<section id="specification-of-immediate-argument-to-dbsendquery-and-friends" class="level2">
<h2 class="anchored" data-anchor-id="specification-of-immediate-argument-to-dbsendquery-and-friends">Specification of <code>immediate</code> argument to <code>dbSendQuery()</code> and friends</h2>
<p>Tom Nolan raised an <a href="https://github.com/r-dbi/DBI/issues/268">issue on GitHub</a>, requesting to specify details of the behavior of query execution. It became apparent that the DBI specification did not account for database drivers where the execution path is substantially different for queries with or without parameters. Recent version of DBI mandated the use of a prepared statement or query for everything.</p>
<p>Similar problems have been noted in MariaDB, Postgres and SQL Server (when accessed through {odbc}): some statements cannot be executed as prepared statements, or <a href="https://github.com/r-dbi/RPostgres/issues/185">prepared statements are disabled</a>. Over the course of several months, the details of the required extension of this API were fleshed out.</p>
<p>The <code>dbSendQuery()</code>, <code>dbGetQuery()</code>, <code>dbSendStatement()</code> and <code>dbExecute()</code> methods gain a new <code>immediate</code> argument. By setting this argument to <code>TRUE</code>, a direct query is created, allowing to execute queries that could not be run previously. Arguably, this is one of those obscure features that are not noted until they are missed.</p>
<p>It is up to the individual backends to add support for this argument. The default value should be made backward-compatible with the previous version of DBI 1.0.0. It has already been implemented in the {odbc} package. Plans to implement this feature in both {RMariaDB} and {RPostgres} are underway.</p>
<section id="examples-using-immediate" class="level3">
<h3 class="anchored" data-anchor-id="examples-using-immediate">Examples using <code>immediate</code></h3>
<pre><code>library(DBI)
con &lt;- dbConnect(odbc::odbc(), dsn = "SQLServerConnection")

# Create local temporary tables:
# Did not work before, temporary table was removed immediately.
dbExecute(con, "CREATE TABLE #temp (a integer)", immediate = TRUE)
dbExecute(con, "INSERT INTO #temp VALUES (1)", immediate = TRUE)

# Show execution plan:
# Did not work before, execution plan was never shown
dbExecute(con, "SET SHOWPLAN_TEXT ON", immediate = TRUE)
dbGetQuery(con, "SELECT * FROM #temp WHERE a &gt; 0")
dbExecute(con, "SET SHOWPLAN_TEXT OFF", immediate = TRUE)</code></pre>
</section>
</section>
<section id="connector-objects" class="level2">
<h2 class="anchored" data-anchor-id="connector-objects">Connector objects</h2>
<p>The existing method in DBI has been to create the driver object and then call <code>dbConnect()</code> with the connection arguments. However there are times when a user may need to do the following:</p>
<ul>
<li>Separate connection arguments from establishing a connection</li>
<li>Serialize the connector to file in order to establish the same connection later</li>
<li>Maintain multiple connectors in a list for testing different DBMS</li>
</ul>
<p>In order to address these use cases, users now have the ability to create a “connector object” that combines the driver and connection arguments, allowing the user to call <code>dbConnect()</code> without additional arguments. This feature is implemented in {DBI}, and works out of the box for all DBI backends.</p>
<section id="example" class="level3">
<h3 class="anchored" data-anchor-id="example">Example</h3>
<pre><code>library(DBI)

# Old way:
drv &lt;- RSQLite::SQLite()
con &lt;- dbConnect(drv, dbname = ":memory:")
dbDisconnect(con)

# New connector object:
cnr &lt;- new("DBIConnector",
  .drv = RSQLite::SQLite(),
  .conn_args = list(dbname = ":memory:")
)
cnr

## &lt;DBIConnector&gt;&lt;SQLiteDriver&gt;
## Arguments:
## $dbname
## [1] ":memory:"

con &lt;- dbConnect(cnr)
dbDisconnect(con)</code></pre>
<p>In addition, arguments can be functions, a useful feature for passwords and other sensitive connection data.</p>
</section>
</section>
<section id="logging-with-the-dblog-package" class="level2">
<h2 class="anchored" data-anchor-id="logging-with-the-dblog-package">Logging with the {dblog} package</h2>
<p>When using applications in production, keeping logs is an invaluable part of a sound infrastructure. The new <a href="https://github.com/r-dbi/dblog">{dblog}</a> package is designed to be as simple as possible. It can be used as a standalone package or in conjunction with packages like {dbplyr}.</p>
<p>{dblog} helps both with troubleshooting as well as auditing the queries that that are used to access a database. Similar to Perl’s DBI::log, the goal of {dblog} is to implement logging for arbitrary DBI backends.</p>
<p>{dblog} is straightforward in its use. Start by initializing a logging driver using <code>dblog()</code> prior to connecting to a database management system. All calls to DBI methods are logged and by default printed to the console (or redirected to a file). The entirety of the logging output is runnable R code, so users can copy, paste, and execute the logging code for debugging.</p>
<section id="using-dblog-to-connect-to-sqlite" class="level3">
<h3 class="anchored" data-anchor-id="using-dblog-to-connect-to-sqlite">Using <code>dblog()</code> to connect to SQLite</h3>
<pre><code>library(dblog)

drv &lt;- dblog(RSQLite::SQLite())
#&gt; drv1 &lt;- RSQLite::SQLite()</code></pre>
</section>
<section id="all-calls-to-dbi-methods-are-logged-by-default-to-the-console" class="level3">
<h3 class="anchored" data-anchor-id="all-calls-to-dbi-methods-are-logged-by-default-to-the-console">All calls to DBI methods are logged, by default to the console</h3>
<pre><code>conn &lt;- dbConnect(drv, file = ":memory:")
#&gt; conn1 &lt;- dbConnect(drv1, file = ":memory:")

dbWriteTable(conn, "iris", iris[1:3, ])
#&gt; dbWriteTable(conn1, name = "iris", value = structure(list(Sepal.Length = c(5.1, 4.9, 
#&gt; 4.7), Sepal.Width = c(3.5, 3, 3.2), Petal.Length = c(1.4, 1.4, 1.3), Petal.Width = c(0.2, 
#&gt; 0.2, 0.2), Species = structure(c(1L, 1L, 1L), .Label = c("setosa", "versicolor", 
#&gt; "virginica"), class = "factor")), row.names = c(NA, 3L), class = "data.frame"), overwrite = FALSE, 
#&gt;     append = FALSE)

data &lt;- dbGetQuery(conn, "SELECT * FROM iris")
#&gt; dbGetQuery(conn1, "SELECT * FROM iris")
#&gt; ##   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#&gt; ## 1          5.1         3.5          1.4         0.2  setosa
#&gt; ## 2          4.9         3.0          1.4         0.2  setosa
#&gt; ## 3          4.7         3.2          1.3         0.2  setosa

dbDisconnect(conn)
#&gt; dbDisconnect(conn1)

data
#&gt;   Sepal.Length Sepal.Width Petal.Length Petal.Width Species
#&gt; 1          5.1         3.5          1.4         0.2  setosa
#&gt; 2          4.9         3.0          1.4         0.2  setosa
#&gt; 3          4.7         3.2          1.3         0.2  setosa</code></pre>
<p>This also works in scenarios where DBI is used under the hood by other packages like <a href="https://dbplyr.tidyverse.org/">dbplyr</a> or <a href="https://tidymodels.github.io/tidypredict/">tidypredict</a>. The log will represent the DBI operations issued, which allows for a better understanding of the internals.</p>
</section>
</section>
<section id="testing-your-infrastructure-for-dbi-compatibility" class="level2">
<h2 class="anchored" data-anchor-id="testing-your-infrastructure-for-dbi-compatibility">Testing your infrastructure for DBI compatibility</h2>
<p>DBItest (on CRAN in version 1.7.0) is currently geared towards usage as part of a package’s test suite. With some effort it is possible to test a database backend against a custom database. This can help verify that your database installation gives expected results when accessed with DBI with specific connection arguments. The <a href="https://dbitest.r-dbi.org/articles/dbitest#external-testing">DBItest article</a> contains a new section that describes how to achieve this, including a primer on using {dblog} to understand the cause of test failures.</p>
</section>
<section id="a-list-of-dbi-backends" class="level2">
<h2 class="anchored" data-anchor-id="a-list-of-dbi-backends">A list of DBI backends</h2>
<p>The new <a href="https://github.com/r-dbi/backends">backends</a> repository lists all known DBI backends, as retrieved via a code search on GitHub. The list is available in the README, and as a static web API for programmatic processing.</p>
</section>
<section id="better-handling-of-time-zones" class="level2">
<h2 class="anchored" data-anchor-id="better-handling-of-time-zones">Better handling of time zones</h2>
<p>Time zones are used to convert between <em>absolute</em> time and <em>civil</em> time, where absolute time exists independent of human-created measures such as calendars, days, and dates, whereas civil time is comprised of years, months, days, hours, minutes, and seconds. For a more in-depth reading on absolute time, civil time, and time zones, please read this excerpt from the <a href="https://github.com/r-dbi/odbc/blob/7b35549f9df935e1d132f6221860f87a6eb64ef6/src/cctz/README.md">ODBC README</a>.</p>
<p>For programming and data analysis, accurate handling time zones is crucial. {odbc} has set an example for how to handle time zones through the inclusion of <code>timezone</code> and <code>timezone_out</code> arguments to <code>dbConnect()</code>. The <code>timezone</code> argument controls the server time zone, which may be different from UTC. The <code>timezone_out</code> argument specifies the time zone to use for displaying times.</p>
<p>This strategy gives the user control over datetime information passed on to and retrieved from the database. Both arguments in combination should be able to support a broad variety of use cases and server setups. {RMariaDB} and {RPostgres} will incorporate this strategy with their next CRAN release. {RPostgres} already has gained a <code>timezone</code> argument in its <code>dbConnect()</code> method.</p>
</section>
<section id="window-function-support-in-rsqlite" class="level2">
<h2 class="anchored" data-anchor-id="window-function-support-in-rsqlite">Window function support in {RSQLite}</h2>
<p>RSQLite 2.1.4 and later includes sqlite &gt;= 3.29.0, which introduces support for window functions.</p>
<pre><code>library(tidyverse)
library(dbplyr)

tbl &lt;- memdb_frame(a = rep(1:2, 5), b = 1:10)

tbl %&gt;% 
  group_by(a) %&gt;%
  window_order(b) %&gt;% 
  mutate(c = cumsum(b)) %&gt;% 
  ungroup()

## # Source:     lazy query [?? x 3]
## # Database:   sqlite 3.30.1 [:memory:]
## # Ordered by: b
##        a     b     c
##    &lt;int&gt; &lt;int&gt; &lt;int&gt;
##  1     1     1     1
##  2     1     3     4
##  3     1     5     9
##  4     1     7    16
##  5     1     9    25
##  6     2     2     2
##  7     2     4     6
##  8     2     6    12
##  9     2     8    20
## 10     2    10    30</code></pre>
</section>
<section id="cii-best-practices-badges-for-all-repos" class="level2">
<h2 class="anchored" data-anchor-id="cii-best-practices-badges-for-all-repos">CII “best practices” badges for all repos</h2>
<p>CII “best practices” have been implemented for {DBItest}, {RMariaDB}, {RPostgres} and {RSQLite}. The {DBItest} repository has a brand-new badge, the badges for the other repositories will follow suit.</p>
</section>
<section id="package-updates" class="level2">
<h2 class="anchored" data-anchor-id="package-updates">Package updates</h2>
<p>The following package versions were sent to CRAN in conjunction with this blog post:</p>
<ul>
<li>DBI 1.1.0 (<a href="https://dbi.r-dbi.org/news/">NEWS</a>)</li>
<li>DBItest 1.7.0 (<a href="https://dbitest.r-dbi.org/news/">NEWS</a>)</li>
<li>RMariaDB 1.0.8 (<a href="https://rmariadb.r-dbi.org/news/">NEWS</a>)</li>
<li>RPostgres 1.2.0 (<a href="https://rpostgres.r-dbi.org/news/">NEWS</a>)</li>
<li>RSQLite 2.1.5 (<a href="https://rsqlite.r-dbi.org/news/">NEWS</a>)</li>
</ul>
<p>Before that, minor updates of the database backend packages were necessary to comply with stricter CRAN checks and toolchain updates.</p>
</section>
<section id="future-work" class="level2">
<h2 class="anchored" data-anchor-id="future-work">Future work</h2>
<p>The remainder of the blog post discusses future directions for DBI and the backend packages.</p>
<section id="dbi-tutorials" class="level3">
<h3 class="anchored" data-anchor-id="dbi-tutorials">DBI tutorials</h3>
<p>Improving documentation is a priority. DBI is still lacking an up-to-date tutorial with a low entry bar that helps users connect to their database and execute queries. The updated <a href="https://dbi.r-dbi.org/">README</a> is a little step forward, but a slightly more comprehensive versions with link to more detailed information would be helpful.</p>
</section>
<section id="terraforming-databases" class="level3">
<h3 class="anchored" data-anchor-id="terraforming-databases">Terraforming databases</h3>
<p>Now that using DBItest to test backends against custom infrastructure is understood, it becomes easier to enhance tests so that not only pristine setups are tested, but also databases with nonstandard settings for time zone, character encoding or collation. <a href="https://www.terraform.io/">Terraform</a> helps automating the setup of databases of different flavors on cloud providers such as Azure or Google Cloud. The desired state of computing infrastructure is specified in a declarative way. This allows testing a much broader variety of databases and configurations, without maintaining expensive infrastructure: databases can be spun up when needed and torn down when done.</p>
<p>It would be helpful to have a selection of open-source and commercial databases in different configuration settings ready for testing.</p>
</section>
<section id="query-cancellation" class="level3">
<h3 class="anchored" data-anchor-id="query-cancellation">Query cancellation</h3>
<p>Currently, {odbc} and many other backends freeze while a query is executed. It is easy to underestimate the runtime of a query, or to accidentally execute a query that is running too long. This severely hampers interactive workflows: a frozen R session means forcibly restarting R, or worse, the development environment.</p>
<p>Mateusz Żółtak has contributed a <a href="https://github.com/r-dbi/RPostgres/pull/193">pull request</a> that implements support for graceful query cancellation in {RPostgres}. <a href="https://github.com/r-dbi/odbc/issues/312">Initial research</a> suggests that for {odbc} it may be possible to implement this in a similar fashion. It remains to be seen if an implementation is viable, and if the database libraries used by {RMariaDB} and {RSQLite} support this mode of operation.</p>
</section>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I’d like to thank Katharina Brunner and Jesse Mostipak for help with composing this blog post.</p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-2.html</guid>
  <pubDate>Thu, 19 Dec 2019 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Maintaining DBI, 1/4</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-1.html</link>
  <description><![CDATA[ 



<p>Much earlier this year my proposal for the third R Consortium project for working on DBI has been accepted. DBI is a set of virtual functions declared in the <em>DBI</em> package. Communication with the database is implemented by <em>DBI backends</em>, packages that import <em>DBI</em> and implement its methods. A common interface is helpful for both users and backend implementers. Users, including package developers for DBMS-agnostic packages, need to memoize only one set of functions. Backend developers can focus on functionality instead of design decisions, and can benefit from a large base of potential users right from the start.</p>
<p>I’m grateful for the trust, and will do my best to make the “Maintaining DBI” project a success. For this round, the main goals are: maintain, enhance, disseminate. The project is delayed mostly becase I grossly underestimated how much time and energy it would take to set up <a href="http://cynkra.com">cynkra</a>. The new joint venture with Christoph Sax consults businesses and organizations on matters related to R, statistics, data, and software. We are strongly committed to R and open-source software, and more priority will be given the “Maintaining DBI” project next year.</p>
<p>This blog post, much later than planned, summarizes the efforts of the past year: presentations at meetups, the “Core Infrastructure Initiative” badge, and activity in the various repositories of the <a href="https://github.com/r-dbi">r-dbi</a> GitHub organization. I’ll repeat the big picture issues from the proposal and present plans for future development.</p>
<section id="presentations-at-meetups" class="level2">
<h2 class="anchored" data-anchor-id="presentations-at-meetups">Presentations at meetups</h2>
<p>I presented DBI at the <a href="https://www.meetup.com/Berlin-R-Users-Group/">Berlin R user group</a>, at the <a href="https://amsterdam2018.satrdays.org/">amstRdays</a>, and at the <a href="https://zurich-r-user-group.github.io/index.html">Zurich R meetup</a>. The presentation in Berlin made me realize that a progress report isn’t that helpful for a general audience. The Zurich version of the presentation featured a DBI intro also suitable for new users, merely highlighting recent developments. <a href="https://bit.ly/2wFJix3">These slides</a>, and the <a href="https://db.rstudio.com/dbi/">intro at db.rstudio.com</a> seem to be the most recent general-purpose introduction materials available. I think an entry-level tutorial would be a good fit for a DBI vignette.</p>
</section>
<section id="cii-badge" class="level2">
<h2 class="anchored" data-anchor-id="cii-badge">CII badge</h2>
<p>From <a href="https://bestpractices.coreinfrastructure.org/en" class="uri">https://bestpractices.coreinfrastructure.org/en</a>:</p>
<blockquote class="blockquote">
<p>The Linux Foundation (LF) Core Infrastructure Initiative (CII) Best Practices badge is a way for Free/Libre and Open Source Software (FLOSS) projects to show that they follow best practices. Projects can voluntarily self-certify, at no cost, by using this web application to explain how they follow each best practice. The CII Best Practices Badge is inspired by the many badges available to projects on GitHub. Consumers of the badge can quickly assess which FLOSS projects are following best practices and as a result are more likely to produce higher-quality secure software.</p>
</blockquote>
<p>The CII badge can be obtained after a self-certification process that comprises ~70 soft and hard questions about the project around the following topics:</p>
<ul>
<li>Basics: Project URLs, license, documentation</li>
<li>Change Control: Version control and version numbers</li>
<li>Reporting: Tracking issues and vulnerabilities</li>
<li>Quality: Build and test system, best practices</li>
<li>Security (software)</li>
<li>Analysis (static and dynamic)</li>
</ul>
<p>After completing the process, projects are entitled to wear a badge like the one below for the DBI project:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://bestpractices.coreinfrastructure.org/projects/1882"><img src="https://maelle.github.io/rdbidotorg/blog/posts/https:/bestpractices.coreinfrastructure.org/projects/1882/badge.svg" class="img-fluid figure-img"></a></p>
<figcaption class="figure-caption">OpenSSF Best Practices</figcaption>
</figure>
</div>
<p>A click on the badge takes you to the detailed assessment. In addition to the badge, completing the self-certification allows the maintainer to rethink if workflows and practices can be improved.</p>
<p>DBI is currently has the “passing” status, the backend packages and <em>DBItest</em> will follow. I have compiled the changes that were necessary to obtain that status below. It appears to be much more difficult but not impossible to obtain the “silver” status.</p>
<section id="necessary-changes-to-the-dbi-package" class="level3">
<h3 class="anchored" data-anchor-id="necessary-changes-to-the-dbi-package">Necessary changes to the DBI package</h3>
<p>Several files had to be added or updated:</p>
<ol type="1">
<li><a href="https://github.com/r-dbi/DBI/blob/master/.github/CONTRIBUTING.md"><code>CONTRIBUTING.md</code></a>: This file describes how to contribute to the project. A link to this file is available when you open a new issue. The function <code>usethis::use_tidy_contributing()</code> created the files which I tweaked a bit.</li>
<li><a href="https://github.com/r-dbi/DBI/blob/master/LICENSE.md"><code>LICENSE.md</code></a>: The full license terms need to be available as part of the project. To create the file, I <a href="https://github.com/r-lib/usethis/pull/472">contributed</a> <code>usethis::use_lgpl_2.1_license()</code>. Because CRAN discourages redistribution of copies of standard license texts in packages, the file has been added to <code>.Rbuildignore</code>. This makes the file available in the GitHub repository, but not package file on CRAN.</li>
<li><a href="https://github.com/r-dbi/DBI#readme"><code>README.md</code></a>: Added missing installation instructions.</li>
</ol>
<p>Though not on the CII badge checklist, I also added:</p>
<ol type="1">
<li><p><a href="https://github.com/r-dbi/DBI/blob/master/.github/ISSUE_TEMPLATE.md"><code>ISSUE_TEMPLATE.md</code></a>: pre-populates the issue description when opening a new issue. This is a tweaked version of the file provided by <code>usethis::use_tidy_issue_template()</code>.</p></li>
<li><p><a href="https://github.com/r-dbi/DBI/blob/master/.github/CODE_OF_CONDUCT.md"><code>CODE_OF_CONDUCT.md</code></a>: The default file as added by <code>usethis::use_code_of_conduct()</code>.</p></li>
</ol>
<p>One badge still had an HTTP image source, after changing it to HTTPS the criterion that the website needs to use TLS was satisfied.</p>
<p>Establishing a process for reporting code vulnerabilities was perhaps the most challenging part. It seems unclear if it applies to R packages at all, in particular to an interface-only package such as DBI. The solution was to add a link with text to the project page <a href="https://dbi.r-dbi.org" class="uri">https://dbi.r-dbi.org</a>, asking to send an e-mail and await further instructions.</p>
</section>
</section>
<section id="future-development" class="level2">
<h2 class="anchored" data-anchor-id="future-development">Future development</h2>
<p>The principal roadmap for future development has been outlined in the project proposal. There are both “hard” and “soft” issues to solve, repeated below, with comments based on experience from the past year.</p>
<section id="hard-issues" class="level3">
<h3 class="anchored" data-anchor-id="hard-issues">“Hard” issues</h3>
<ol type="1">
<li><p>The test suite for the DBI specificaton in <code>DBItest</code> is currently designed to run as part of the package checks. The next step is to support running the test suite against a particular R + DBMS installation, to ensure that code interoperating with that DBMS in that environment runs as expected.</p>
<ul>
<li>Shouldn’t be too hard, but need to keep the second “soft” issue in mind.</li>
</ul></li>
<li><p>Users expect the hard disk or the DBMS to be the limiting factor for loading data, but DBI still lacks a consistent interface for fast data import.</p>
<ul>
<li>The new <a href="https://cran.r-project.org/package=arkdb"><em>arkdb</em> package</a> offers a dedicated interface for importing data, I still think this functionality should better live there (or elsewhere).</li>
</ul></li>
<li><p>The syntax for query placeholders currently depends on the DBMS. A consistent interface would be useful, in particular for implementers of packages that compute on the database.</p>
<ul>
<li>This has already caused some confusion. Shouldn’t be too hard either, but requires a compatibility mode so that existing code doesn’t break.</li>
</ul></li>
<li><p>The <code>RPostgres</code> package now has special handling for geometry data. A generic extension to arbitrary data types via hooks would allow e.g.&nbsp;returning JSON data directly as a <code>"json"</code> class without user-initiated manual conversion.</p>
<ul>
<li>This seems to be a bigger problem, requiring some thought and design.</li>
</ul></li>
</ol>
</section>
<section id="soft-issues" class="level3">
<h3 class="anchored" data-anchor-id="soft-issues">“Soft” issues</h3>
<ol type="1">
<li><p>Some users reported installation problems on specific architectures, or connectivity problems with certain databases, or other specific issues. Making the new backends accessible for various combinations of OS/hardware, software, and configuration, will help the adoption of the new packages.</p>
<ul>
<li>I remember seeing many SSL and timezone issues, as well as genuine bugs like the representation of times before 1970 on Windows. Expect some progress for the second blog post.</li>
</ul></li>
<li><p>The internal architecture of the DBI specification in <code>DBItest</code> requires a bit of reworking. Currently, it is difficult to understand a test failure without inspecting the source code of <code>DBItest</code>. It is difficult to locate the source of a failure in the specification and in the code. Ideally, each test failure would come with a precise link to the part of the specification that is violated, and with a simple sequence of DBI method calls that allow replicating the failure externally.</p>
<ul>
<li>That code I wrote 1-2 years ago requires some attention…</li>
</ul></li>
<li><p>The communication related to the projects has been rather terse so far. The new website <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> can host blog posts highlighting different aspects of DBI, and serve as a resource for advice on connecting R with databases and computing on the database. This includes coordination and support for developments around DBI like <em>sqlr</em>, an interface for data definition statements on top of DBI.</p>
<ul>
<li>Together with the new <a href="https://github.com/terrytangyuan/ctv-databases">Databases CRAN Task View</a> maintained by Yuan (Terry) Tang and <a href="https://db.rstudio.com/" class="uri">https://db.rstudio.com/</a>, the <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> should become a viable resource for new and experienced users alike. New users should be directed to tutorials and introductory material, whereas experienced users should expect to find pointers to solve the most common problems. The role of each of these websites remains to be shaped, some overlap may be desired.</li>
</ul></li>
<li><p>All operations on DBI currently block until a result is available or the DBMS has indicated completion. Asynchronous operations allow parallel processing of multiple queries or statements, however some research is necessary to understand to what extent this can be supported realistically in DBI and for the existing backends.</p>
<ul>
<li>Additional arguments to <code>dbConnect()</code>, like the new <code>check_interrupts</code> argument <a href="https://github.com/r-dbi/RPostgres/pull/193">contributed to <em>RPostgres</em> by Mateusz Żółtak</a>, are an option to experiment with asynchronous processing without disrupting existing code.</li>
</ul></li>
</ol>
<p>These lists are not comprehensive, new issues may surface over time, or the importance of issues mentioned above may fade.</p>
</section>
</section>
<section id="outlook-next-blog-post" class="level2">
<h2 class="anchored" data-anchor-id="outlook-next-blog-post">Outlook: next blog post</h2>
<p>The “Maintaining DBI” project is driven by blog posts. I promised four blog posts, describing the ongoing maintenance and development. Each blog post will get a corresponding GitHub project, like the project for <a href="https://github.com/orgs/r-dbi/projects/2">this</a> and for the <a href="https://github.com/orgs/r-dbi/projects/3">next</a> blog post.</p>
<p>For the next iteration, I plan to improve documentation, do a release round for all packages, furnish more packages with a CII badge, review several new packages that build on top of <em>DBI</em>, and improve my responsiveness.</p>
<p>A Walkthrough for first-time DBI users seems to be the highest priority, perhaps accompanied by an online course. Other documentation improvements mostly will address <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a>.</p>
<p>The following is an excerpt of changes in the forthcoming CRAN releases of the DBI packages:</p>
<ul>
<li><em>RSQLite</em>: window functions!</li>
<li><em>RMariaDB</em>: better handling for time zones</li>
<li><em>DBItest</em>: minor improvements</li>
</ul>
<p>New packages worth reviewing include:</p>
<ul>
<li><a href="https://cran.r-project.org/package=arkdb"><em>arkdb</em></a>: Consistent (and fast?) import and export</li>
<li><a href="https://cran.r-project.org/package=flobr"><em>flobr</em></a>: Converting files to blobs and back</li>
<li><a href="https://github.com/nbenn/sqlr"><em>sqlr</em></a>: SQLAlchemy-like DSL for data definition, work in progress</li>
<li><a href="https://cran.r-project.org/package=dbplot"><em>dbplot</em></a>: Plotting from the database</li>
<li>and many others.</li>
</ul>
<p>Adding CII badges for the backend packages and <em>DBItest</em> will give a more consistent appearance of the entire project.</p>
<p>As a New Year’s resolution, I pledge to do a better job as package maintainer for <em>DBI</em> and related packages. I reserved a few hours each Monday to respond to issues raised on GitHub and other channels (<a href="https://stackoverflow.com/">SO</a>, <a href="https://community.rstudio.com/">RStudio Community</a>, Twitter, and the somewhat underappreciated <a href="https://stat.ethz.ch/mailman/listinfo/r-sig-db">R-SIG-DB mailing list</a>). CI builds on Travis and AppVeyor also require occasional intervention. The remaining time will be spent on resolving known problems.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>Thanks to all contributors to <em>DBI</em> and the other projects in the <a href="https://github.com/r-dbi">r-dbi organization</a>!</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="https://maelle.github.io/rdbidotorg/blog/posts/https:/krlmlr.github.io/dbi-slides/2018-09-zurich-meetup/img/contributors.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">DBI contributors</figcaption>
</figure>
</div>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-3-1.html</guid>
  <pubDate>Mon, 31 Dec 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Done “Establishing DBI”!?</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-2-final.html</link>
  <description><![CDATA[ 



<p>The “Establishing DBI” project, funded by the R consortium, started about a year ago. It includes the completion of two new backends, <em>RPostgres</em> and <em>RMariaDB</em>, and a quite a few interface extensions and specifications. Learn more about DBI, R’s database interface, on <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a>.</p>
<p>This blog post showcases only the visible changes, a substantial amount of work went into extending the DBI specification and making the three open-source database backends compliant to it. After describing the release of the two new backends <em>RMariaDB</em> and <em>RPostgres</em>, I’ll be discussing the following improvements:</p>
<ul>
<li>Consistent support for accessing tables in schemas</li>
<li>Quoting literal values, in addition to strings and identifiers</li>
<li>More fine-grained creation of tables</li>
<li>Reading and writing 64-bit integers</li>
<li>Reading geometry columns from a PostGIS database</li>
<li>Handling of duplicate column names</li>
<li>New helpers in <em>DBI</em></li>
<li>Reusing code across backends</li>
</ul>
<p>I conclude with an outlook on things left to do.</p>
<section id="release-of-rpostgres-and-rmariadb" class="level2">
<h2 class="anchored" data-anchor-id="release-of-rpostgres-and-rmariadb">Release of <em>RPostgres</em> and <em>RMariaDB</em></h2>
<p>The DBI specification has been formulated in the preceding R consortium project, “Improving DBI”. It is both an automated test suite and a human-readable description of behavior, implemented in the <em>DBItest</em> package. For this project, I extended this specification and could also use it to implement <em>RPostgres</em> and <em>RMariaDB</em>: for once, test-driven development was pure pleasure, because the tests were already there!</p>
<p>I took over maintenance of the <em>RPostgres</em> and <em>RMariaDB</em> packages, which are complete rewrites of the <em>RPostgreSQL</em> and <em>RMySQL</em> packages, respectively. These packages use C++ (with <em>Rcpp</em>) as glue between R and the native database libraries. A reimplementation and release under a different name has made it much easier to fully conform to the DBI specification: only listing temporary tables and casting to blob or character is not supported by <em>RMariaDB</em> (due to a limitation of the DBMS), all other parts of the specification are fully covered.</p>
<p>Projects that use <em>RPostgreSQL</em> or <em>RMySQL</em> can continue to do so, or switch to the new backends at their own pace (which likely requires some changes to the code). For new projects I recommend <em>RPostgres</em> or <em>RMariaDB</em> to take advantage of the thorougly tested codebases and of the consistency across backends.</p>
</section>
<section id="schema-support" class="level2">
<h2 class="anchored" data-anchor-id="schema-support">Schema support</h2>
<p>Consistent access of tables in database schemas was planned for the “Improving DBI” project already, but I have implemented it only recently. It felt safer to see how the interface works on three backends, as opposed to implementing it for just <em>RSQLite</em> and then perhaps having to adapt it.</p>
<p>The new <code>Id()</code> function constructs identifiers. All arguments must be named, yet <em>DBI</em> doesn’t specify the argument names, because DBMS have an inconsistent notion of namespaces. The objects returned by <code>Id()</code> are “dumb”, they gain meaning only when used in methods such as <code>dbQuoteIdentifier()</code> or <code>dbWriteTable()</code>.</p>
<p>For listing database objects in schemas, the new <code>dbListObjects()</code> generic can be used. It returns a data frame that contains identifiers (like those created by the <code>Id()</code> function) and a flag that indicates if the identifier is complete (i.e., pointing to a table or view) or a prefix. Incomplete identifiers can be passed to <code>dbListObjects()</code> again, which allows traversing the tree of database objects.</p>
<p>The following example assumes a schema <code>my_schema</code>. A table named <code>my_table</code> is created in this schema, objects are listed, and the table is read again.</p>
<pre><code>library(RPostgres)
pg_conn &lt;- dbConnect(Postgres())

table_name &lt;- Id(schema = "my_schema", table = "my_table")
table_name

## &lt;Id&gt; schema = my_schema, table = my_table

data &lt;- data.frame(a = 1:3, b = letters[1:3])
dbWriteTable(pg_conn, table_name, data)

dbListObjects(pg_conn)

##                               table is_prefix
## 1    &lt;Id&gt; table = geography_columns     FALSE
## 2     &lt;Id&gt; table = geometry_columns     FALSE
## 3      &lt;Id&gt; table = spatial_ref_sys     FALSE
## 4       &lt;Id&gt; table = raster_columns     FALSE
## 5     &lt;Id&gt; table = raster_overviews     FALSE
## 6             &lt;Id&gt; table = topology     FALSE
## 7                &lt;Id&gt; table = layer     FALSE
## 8                 &lt;Id&gt; table = temp     FALSE
## 9            &lt;Id&gt; schema = topology      TRUE
## 10          &lt;Id&gt; schema = my_schema      TRUE
## 11 &lt;Id&gt; schema = information_schema      TRUE
## 12         &lt;Id&gt; schema = pg_catalog      TRUE
## 13             &lt;Id&gt; schema = public      TRUE

dbListObjects(
  pg_conn,
  prefix = Id(schema = "my_schema")
)

##                                       table is_prefix
## 1 &lt;Id&gt; schema = my_schema, table = my_table     FALSE

dbReadTable(pg_conn, table_name)

##   a b
## 1 1 a
## 2 2 b
## 3 3 c</code></pre>
<p>In addition to <code>dbReadTable()</code> and <code>dbWriteTable()</code>, also <code>dbExistsTable()</code> and <code>dbRemoveTable()</code> and the new <code>dbCreateTable()</code> and <code>dbAppendTable()</code> (see below) support an <code>Id()</code> object as table name. The <code>dbQuoteIdentifier()</code> method converts these objects to SQL strings. Some operations (e.g.&nbsp;checking if a table exists) require the inverse, the new <code>dbUnquoteIdentifier()</code> generic takes care of converting valid SQL identifiers to (a list of) <code>Id()</code> objects:</p>
<pre><code>quoted &lt;- dbQuoteIdentifier(pg_conn, table_name)
quoted

## &lt;SQL&gt; "my_schema"."my_table"

dbUnquoteIdentifier(pg_conn, quoted)

## [[1]]
## &lt;Id&gt; schema = my_schema, table = my_table</code></pre>
<p>The new methods work consistently across backends, only <em>RSQLite</em> is currently restricted to the default schema. (Schemas in <em>RSQLite</em> are created by attaching another database, this use case seemed rather exotic but can be supported with the new infrastructure.)</p>
</section>
<section id="quoting-literal-values" class="level2">
<h2 class="anchored" data-anchor-id="quoting-literal-values">Quoting literal values</h2>
<p>When working on the database backends, it has become apparent that quoting strings and identifiers isn’t quite enough. Now there is a way to quote arbitrary values, i.e.&nbsp;convert them to a string that can be pasted into an SQL query:</p>
<pre><code>library(RSQLite)
sqlite_conn &lt;- dbConnect(SQLite())

library(RMariaDB)
mariadb_conn &lt;- dbConnect(MariaDB(), dbname = "test")

dbQuoteLiteral(sqlite_conn, 1.5)

## &lt;SQL&gt; 1.5

dbQuoteLiteral(mariadb_conn, 1.5)

## &lt;SQL&gt; 1.5

dbQuoteLiteral(pg_conn, 1.5)

## &lt;SQL&gt; 1.5::float8

dbQuoteLiteral(mariadb_conn, Sys.time())

## &lt;SQL&gt; '20180501204025'

dbQuoteLiteral(pg_conn, Sys.time())

## &lt;SQL&gt; '2018-05-01 22:40:25'::timestamp</code></pre>
<p>The default implementation works for ANSI SQL compliant DBMS, the method for <em>RPostgres</em> takes advantage of the <code>::</code> casting operator as seen in the examples.</p>
</section>
<section id="more-fine-grained-creation-of-tables" class="level2">
<h2 class="anchored" data-anchor-id="more-fine-grained-creation-of-tables">More fine-grained creation of tables</h2>
<p><em>DBI</em> supports storing data frames as tables in the database via <code>dbWriteTable()</code>. This operation consists of multiple steps:</p>
<ul>
<li>Checking if a table of this name exists, if yes:
<ul>
<li>If <code>overwrite = TRUE</code>, removing the table</li>
<li>If not, throwing an error</li>
</ul></li>
<li>Creating the table with the correct field structure</li>
<li>Preparing the data for writing</li>
<li>Writing the data</li>
</ul>
<p>To reduce complexity and allow for more options without cluttering the argument list of <code>dbWriteTable()</code>, <em>DBI</em> now provides generics for the individual steps:</p>
<ul>
<li><p>The existing <code>dbRemoveTable()</code> generic has been extended with <code>temporary</code> and <code>fail_if_missing</code> arguments. Setting <code>temporary = TRUE</code> makes sure that only temporaries are removed. By default, trying to remove a table that doesn’t exist fails, setting <code>fail_if_missing = FALSE</code> changes this behavior to a silent success.</p></li>
<li><p>The new <code>dbCreateTable()</code> generic accepts a data frame or a character vector of DBMS data types and creates a table in the database. It builds upon the existing <code>sqlCreateTable()</code> generic and also supports the <code>temporary</code> argument. If a table by that name already exists, an error is raised.</p></li>
<li><p>The new <code>dbAppendTable()</code> generic uses a prepared statement (created via <code>sqlAppendTableTemplate()</code>) to efficiently insert rows into the database. This avoids the internal overhead of converting values to SQL literals.</p></li>
</ul>
<p>The following example shows the creation and population of a table with the new methods.</p>
<pre><code>table_name

## &lt;Id&gt; schema = my_schema, table = my_table

dbRemoveTable(pg_conn, table_name, fail_if_missing = FALSE)

dbCreateTable(pg_conn, table_name, c(a = "int8", b = "float8"))

dbAppendTable(pg_conn, table_name, data.frame(a = 1:3, b = 1:3))

## [1] 3

str(dbReadTable(pg_conn, table_name))

## 'data.frame':    3 obs. of  2 variables:
##  $ a:integer64 1 2 3 
##  $ b: num  1 2 3</code></pre>
<p>The <code>dbWriteTable()</code> methods in the three backends have been adapted to use the new methods.</p>
</section>
<section id="support-for-64-bit-integers" class="level2">
<h2 class="anchored" data-anchor-id="support-for-64-bit-integers">Support for 64-bit integers</h2>
<p>As seen in the previous example, 64-bit integers can be read from the database. The three backends <em>RSQLite</em>, <em>RPostgres</em> and <em>RMariaDB</em> now also support writing 64-bit integers via the <em>bit64</em> package:</p>
<pre><code>data &lt;- data.frame(a = bit64::as.integer64(4:6), b = 4:6)
dbAppendTable(pg_conn, table_name, data)

## [1] 3

str(dbReadTable(pg_conn, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a:integer64 1 2 3 4 5 6 
##  $ b: num  1 2 3 4 5 6</code></pre>
<p>Because R still lacks support for native 64-bit integers, the <em>bit64</em> package feels like the best compromise: the returned values can be computed on, or coerced to <code>integer</code>, <code>numeric</code> or even <code>character</code> depending on the application. In some cases, it may be useful to always coerce. This is where the new <code>bigint</code> argument to <code>dbConnect()</code> helps:</p>
<pre><code>pg_conn_int &lt;- dbConnect(Postgres(), bigint = "integer")
str(dbReadTable(pg_conn_int, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a: int  1 2 3 4 5 6
##  $ b: num  1 2 3 4 5 6

pg_conn_num &lt;- dbConnect(Postgres(), bigint = "numeric")
str(dbReadTable(pg_conn_num, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a: num  1 2 3 4 5 6
##  $ b: num  1 2 3 4 5 6

pg_conn_chr &lt;- dbConnect(Postgres(), bigint = "character")
str(dbReadTable(pg_conn_chr, table_name))

## 'data.frame':    6 obs. of  2 variables:
##  $ a: chr  "1" "2" "3" "4" ...
##  $ b: num  1 2 3 4 5 6</code></pre>
<p>The <code>bigint</code> argument works consistently across the three backends <em>RSQLite</em>, <em>RPostgres</em> and <em>RMariaDB</em>, the DBI specification contains a test for and a description of the requirements.</p>
</section>
<section id="geometry-columns" class="level2">
<h2 class="anchored" data-anchor-id="geometry-columns">Geometry columns</h2>
<p>PostgreSQL has support for user-defined data types, this is used e.g.&nbsp;by PostGIS to store spatial data. Before, user-defined data types were returned as character values, with a warning. Thanks to a contribution by Etienne B. Racine:</p>
<ul>
<li>the warnings are gone,</li>
<li>the user-defined data type is now stored in an attribute of the column in the data frame,</li>
<li>details on columns with user-defined data types are available in <code>dbColumnInfo()</code>.</li>
</ul>
<!-- -->
<pre><code>dbCreateTable(
  pg_conn,
  "geom_test",
  c(id = "int4", geom = "geometry(Point, 4326)")
)

data &lt;- data.frame(
  id = 1,
  geom = "SRID=4326;POINT(-71.060316 48.432044)",
  stringsAsFactors = FALSE
)
dbAppendTable(pg_conn, "geom_test", data)

## [1] 1

str(dbReadTable(pg_conn, "geom_test"))

## 'data.frame':    1 obs. of  2 variables:
##  $ id  : int 1
##  $ geom:Class 'pq_geometry'  chr "0101000020E61000003CDBA337DCC351C06D37C1374D374840"

res &lt;- dbSendQuery(pg_conn, "SELECT * FROM geom_test")
dbColumnInfo(res)

##   name      type   .oid .known .typname
## 1   id   integer     23   TRUE     int4
## 2 geom character 101529  FALSE geometry

dbClearResult(res)</code></pre>
<p>Special support for geometry columns is currently available only in <em>RPostgres</em>.</p>
</section>
<section id="duplicate-column-names" class="level2">
<h2 class="anchored" data-anchor-id="duplicate-column-names">Duplicate column names</h2>
<p>The specification has been extended to disallow duplicate, empty or <code>NA</code> column names. The deduplication used by our three backends is similar to that used by <code>tibble::set_tidy_names()</code>, but the DBI specification does not require any particular deduplication mechanism. Syntactic names aren’t required either:</p>
<pre><code>dbGetQuery(sqlite_conn, "SELECT 1, 2, 3")

##   1 2 3
## 1 1 2 3

dbGetQuery(sqlite_conn, "SELECT 1 AS a, 2 AS a, 3 AS `a..2`")

##   a a..2 a..3
## 1 1    2    3

dbGetQuery(mariadb_conn, "SELECT 1, 2, 3")

##   1 2 3
## 1 1 2 3

dbGetQuery(mariadb_conn, "SELECT 1 AS a, 2 AS a, 3 AS `a..2`")

##   a a..2 a..3
## 1 1    2    3

dbGetQuery(pg_conn, "SELECT 1, 2, 3")

##   ?column? ?column?..2 ?column?..3
## 1        1           2           3

dbGetQuery(pg_conn, 'SELECT 1 AS a, 2 AS a, 3 AS "a..2"')

##   a a..2 a..3
## 1 1    2    3</code></pre>
</section>
<section id="helpers" class="level2">
<h2 class="anchored" data-anchor-id="helpers">Helpers</h2>
<p>Two little helper generics have been added.</p>
<p>The new <code>dbIsReadOnly()</code> generic (contributed by Anh Le) should return <code>TRUE</code> for a read-only connection. This is not part of the specification yet.</p>
<p>The <code>dbCanConnect()</code> tests a set of connection parameters. The default implementation simply connects and then disconnects upon success. For DBMS that can provide more efficient methods of checking connectivity, a lighter-weight implementation of this method may give a better experience.</p>
<p>None of the three backends currently provide specialized implementations for these generics.</p>
</section>
<section id="code-reuse" class="level2">
<h2 class="anchored" data-anchor-id="code-reuse">Code reuse</h2>
<p>I have made some efforts to extract common C++ classes for assembling data frames and prepare them for reuse. The C++ source code for the three backends contains files prefixed with <code>Db</code>, these are almost identical across the backends. The planned packaging into the <em>RKazam</em> package had to yield to higher-priority features described above.</p>
<p>The situation in the R code is similar: I have found myself copy-pasting code from one backend into another because I didn’t feel it’s ready (or standardized enough) to be included in the <em>DBI</em> package.</p>
<p>For both use cases, a code reuse strategy based on copying/updating template files or reconciling files may be more robust than the traditional importing mechanisms offered by R.</p>
</section>
<section id="outlook" class="level2">
<h2 class="anchored" data-anchor-id="outlook">Outlook</h2>
<p>The upcoming CRAN release of <em>DBI</em>, <em>DBItest</em> and the three backends <em>RSQLite</em>, <em>RMariaDB</em> and <em>RPostgres</em> are an important milestone. Stability is important when more and more users and projects use the new backends. Nevertheless, I see quite a few potential improvements that so far were out of scope of the “Improving DBI” and “Establishing DBI” projects:</p>
<ol type="1">
<li><p>Support running the test suite locally, to validate adherence to DBI for a particular installation.</p></li>
<li><p>Consistent fast data import.</p></li>
<li><p>Consistent query placeholders (currently <code>$1</code> for <em>RPostgres</em> and <code>?</code> for many other backends).</p></li>
<li><p>Support for arbitrary data types via hooks.</p></li>
<li><p>Assistance with installation problems on specific architectures, or connectivity problems with certain databases, or other specific issues.</p></li>
<li><p>Rework the internal architecture of <em>DBItest</em> to simplify locating test failures.</p></li>
<li><p>Improve the <a href="https://r-dbi.org" class="uri">https://r-dbi.org</a> website.</p></li>
<li><p>Non-blocking queries.</p></li>
</ol>
<p>I have submitted another proposal to the R Consortium, hoping to receive support with these and other issues.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>I’d like to thank the R Consortium for their generous financial support. Many thanks to the numerous contributors who helped make the past two projects a success.</p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-2-final.html</guid>
  <pubDate>Tue, 01 May 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Connecting to open source databases</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/rstudio-conf.html</link>
  <description><![CDATA[ 



<section id="link-to-video" class="level2">
<h2 class="anchored" data-anchor-id="link-to-video">Link to video</h2>
<p>
<a href="https://www.rstudio.com/resources/videos/connecting-to-open-source-databases/?wvideo=yf1vdwugk5"><img src="https://maelle.github.io/rdbidotorg/blog/posts/https:/embedwistia-a.akamaihd.net/deliveries/6cc6be1f7e21a6ecd6640c0068ecd86a94c235d0.jpg?image_play_button_size=2x&amp;image_crop_resized=960x540&amp;image_play_button=1&amp;image_play_button_color=4287c7e0" style="width: 400px; height: 225px;" width="400" height="225"></a>
</p>
<p>
<a href="https://www.rstudio.com/resources/videos/connecting-to-open-source-databases/?wvideo=yf1vdwugk5">Connecting to open source databases – RStudio</a>
</p>
</section>
<section id="slides" class="level2">
<h2 class="anchored" data-anchor-id="slides">Slides</h2>
<div style="position:relative;padding-top:56.25%;">
<p><iframe src="https://krlmlr.github.io/dbi-slides/2018-02-san-diego-rstudio-conf" frameborder="0" allowfullscreen="" style="position:absolute;top:0;left:0;width:100%;height:100%;"></iframe></p>
</div>
<p><a href="https://krlmlr.github.io/dbi-slides/2018-02-san-diego-rstudio-conf" target="_blank">Full screen version</a></p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/rstudio-conf.html</guid>
  <pubDate>Fri, 02 Feb 2018 00:00:00 GMT</pubDate>
</item>
<item>
  <title></title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-1-final.html</link>
  <description><![CDATA[ 



<p>The “Improving DBI” project, funded by the R consortium, started about a year ago. It includes</p>
<ol type="1">
<li>the definition and implementation of a testable specification for DBI,</li>
<li>making <code>RSQLite</code> fully compliant to the new specification.</li>
</ol>
<p>Besides the established <code>DBI</code> and <code>RSQLite</code> packages, I have spent a lot of time on the new <code>DBItest</code> package. Final updates to these packages will be pushed to CRAN end of May this year, to give downstream maintainers some time to accommodate.</p>
<p>The follow-up project “Establishing DBI” will focus on fully DBI-compliant backends for MySQL/MariaDB and PostgreSQL, and on minor updates to the specs where appropriate.</p>
<section id="dbitest-specification" class="level2">
<h2 class="anchored" data-anchor-id="dbitest-specification"><code>DBItest</code>: Specification</h2>
<p>A comprehensive backend-agnostic test suite for DBI backends is provided by the new <code>DBItest</code> package. When the project started, it was merely a collection of test cases. I have considerably expanded the test cases and provided a human-readable description for each, using literate programming techniques powered by <code>roxygen2</code>. The <code>DBI</code> package weaves these chunks of text to a single document that describes all test cases covered by the test suite, the textual <em>DBI specification</em>. This approach ensures that further updates to the specification are reflected in both the automatic tests and the text.</p>
<p>This package is aimed at backend implementers, who now can programmatically check with very little effort if their DBI backend conforms to the DBI specification. The verification can be integrated in the automated tests which are run as part of R’s package check mechanism in <code>R CMD check</code>. The <code>odbc</code> package, a new DBI-compliant interface to the ODBC interface, has been using <code>DBItest</code> from day one to enable test-driven development. The <code>bigrquery</code> package is another user of <code>DBItest</code>.</p>
<p>Because not all DBMS support all aspects of DBI, the <code>DBItest</code> package allows to restrict which parts of the specification are tested, or “tweak” certain aspects of the tests, e.g., the format of placeholders in parametrized queries. Adapting to other DBMS may require more work due to subtle differences in the implementation of SQL between various DBMS.</p>
</section>
<section id="dbi-definition" class="level2">
<h2 class="anchored" data-anchor-id="dbi-definition"><code>DBI</code>: Definition</h2>
<p>This package has been around since 2001, it defines the actual <em>DataBase Interface</em> in R. I have taken over maintenance, and released versions 0.4-1, 0.5-1, and 0.6-1, with release of version 0.7 pending.</p>
<p>The most prominent change in this package is, of course, the textual <a href="https://cran.r-project.org/web/packages/DBI/vignettes/spec.html">DBI specification</a>, which is included as an HTML vignette in the package. The documentation for the various methods defined by <code>DBI</code> is obtained directly from the specification. These help topics are combined in a sensible order to a single, self-contained document. This format is useful for both DBI users and implementers: users can look up the behavior of a method directly from its help page, and implementers can browse a comprehensive document that describes all aspects of the interface. I have also revised the description and the examples for all help topics.</p>
<p>Other changes include:</p>
<ul>
<li>the definition of new generics <code>dbSendStatement()</code> and <code>dbExecute()</code>, for backends that distinguish between queries that return a table and statements that manipulate data,</li>
<li>the new <code>dbWithTransaction()</code> generic and the <code>dbBreak()</code> helper function, thanks Barbara Borges Ribero,</li>
<li>improved or new default implementations for methods like <code>dbGetQuery()</code>, <code>dbReadTable()</code>, <code>dbQuoteString()</code>, <code>dbQuoteIdentifier()</code>,</li>
<li>internal changes that allow methods that don’t have a meaningful return value to return silently,</li>
<li>translation of a helper function from C++ to R, to remove the dependency on <code>Rcpp</code> (thanks Hannes Mühleisen).</li>
</ul>
<p>Fortunately, none of the changes seemed to have introduced any major regressions with downstream packages. The <a href="https://github.com/rstats-db/DBI/blob/master/NEWS.md">news</a> contain a comprehensive list of changes.</p>
</section>
<section id="rsqlite-implementation" class="level2">
<h2 class="anchored" data-anchor-id="rsqlite-implementation"><code>RSQLite</code>: Implementation</h2>
<p><code>RSQLite</code> 1.1-2 is a complete rewrite of the original C implementation. Before focusing on compliance to the new DBI specification, it was important to assert compatibility to more than 100 packages on CRAN and Bioconductor that use <code>RSQLite</code>. These packages revealed many usage patterns that were difficult to foresee. Most of these usage patterns are supported in version 1.1-2, the more esoteric ones (such as supplying an <code>integer</code> where a <code>logical</code> is required) trigger a warning.</p>
<p>Several rounds of “revdep checking” were necessary before most packages showed no difference in their check output compared to the original implementation. The downstream maintainers and the Bioconductor team were very supportive, and helped spotting functional and performance regressions during the release process. Two point releases were necessary to finally achieve a stable state.</p>
<p>Supporting 64-bit integers also was trickier than anticipated. There is no built-in way to represent 64-bit integers in R. The <code>bit64</code> package works around this limitation by using a <code>numeric</code> vector as storage, which also happens to use 8 bytes per element, and providing coercion functions. But when an integer column is fetched, it cannot be foreseen if a 64-bit value will occur in the result, and smaller integers must use R’s built-in <code>integer</code> type. For this purpose, an efficient data structure for collecting vectors, which is capable of changing the data type on the fly, has been implemented in C++. This data structure will be useful for many other DBI backends that need support for a 64-bit integer data type, and will be ported to the <code>RKazam</code> package in the follow-up project.</p>
<p>Once the DBI specification was completed, the process of making <code>RSQLite</code> compliant was easy: enable one of the disabled tests, fix the code, make sure all tests pass, rinse, and repeat. If you haven’t tried it, I seriosly recommend test-driven development, especially when the tests are already implemented.</p>
<p>The upcoming release of <code>RSQLite</code> 2.0 will require stronger adherence to the DBI specification also from callers. Where possible I tried to maintain backward compatibility, but in some cases breaks were inevitable because otherwise I’d have had to introduce far too many exceptions and corner cases in the DBI spec. For instance, row names are no longer included by default when writing or reading tables. The original behavior can be reenabled by calling <code>pkgconfig::set_config()</code>, so that packages or scripts that rely on row names continue to work as before. (The setting is active for the duration of the session, but only for the caller that has called <code>pkgconfig::set_config()</code>.) I’m happy to include compatibility switches for other breaking changes if necessary and desired, to achieve both adherence to the specs and compatibility with existing behavior.</p>
<p>A comprehensive list of changes can be found in the <a href="https://github.com/rstats-db/RSQLite/blob/master/NEWS.md">news</a>.</p>
</section>
<section id="other-bits-and-pieces" class="level2">
<h2 class="anchored" data-anchor-id="other-bits-and-pieces">Other bits and pieces</h2>
<p>The <code>RKazam</code> package is a ready-to-use boilerplate for a DBI backend, named after the hypothetical DBMS used as example in a DBI vignette. It already “passes” all tests of the <code>DBItest</code> package, mostly by calling a function that skips the current test. Starting a DBI backend from scratch requires only copying and renaming the package’s code.</p>
<p>R has limited support for time-of-day data. The <code>hms</code> package aims at filling this gap. It will be useful especially in the follow-up project, because SQLite doesn’t have an intrinsic type for time-of-day data, unlike many other DBMS.</p>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next steps</h2>
<p>The ensemble CRAN release of the three packages <code>DBI</code>, <code>DBItest</code> and <code>RSQLite</code> will occur in parallel to the startup phase for the “Establishing DBI” follow-up project. This project consists of:</p>
<ul>
<li>Fully DBI compatible backends for MySQL/MariaDB and Postgres</li>
<li>A backend-agnostic C++ data structure to collect column data in the <code>RKazam</code> package</li>
<li>Support for spatial data</li>
</ul>
<p>In addition, it will contain an update to the DBI specification, mostly concerning support for schemas and for querying the structure of the table returned for a query. Targeting three DBMS instead of one will help properly specify these two particularly tricky parts of DBI. I’m happy to take further feedback from users and backend implementers towards further improvement of the DBI specification.</p>
</section>
<section id="acknowledgments" class="level2">
<h2 class="anchored" data-anchor-id="acknowledgments">Acknowledgments</h2>
<p>Many thanks to the R Consortium, who has sponsored this project, and to the many contributors who have spotted problems, suggested improvements, submitted pull requests, or otherwise helped make this project a great success. In particular, I’d like to thank Hadley Wickham, who suggested the idea, supported initial development of the <code>DBItest</code> package, and provided helpful feedback; and Christoph Hösler, Hannes Mühleisen, Imanuel Costigan, Jim Hester, Marcel Boldt, and <span class="citation" data-cites="thrasibule">@thrasibule</span> for using it and contributing to it. I enjoyed working on this project, looking forward to “Establishing DBI”!</p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-1-final.html</guid>
  <pubDate>Mon, 15 May 2017 00:00:00 GMT</pubDate>
</item>
<item>
  <title>Halfway through “Improving DBI”</title>
  <dc:creator>Kirill Müller</dc:creator>
  <link>https://maelle.github.io/rdbidotorg/blog/posts/dbi-1-halfway.html</link>
  <description><![CDATA[ 



<p>In early 2016 the R Consortium partially accepted my “Improving DBI” proposal. An important part is the design and implementation of a testable DBI specification. Initially I also proposed to make three DBI backends to open-source databases engines (RSQLite, RMySQL, and RPostgres) compatible to the new DBI specification, but funding allows to work on only one DBI backend. I chose RSQLite for a number of reasons:</p>
<ul>
<li>It is a very important package, judging by the number of reverse CRAN and Bioconductor dependencies</li>
<li>It’s easy to work with, because everything (including the database engine) is bundled with the package</li>
<li>It seemed to be the most advanced package, closest to the (yet to be completed) DBI specification</li>
<li>An <a href="https://twitter.com/krlmlr/status/712950420969283584">informal Twitter poll</a> supports this decision by a tiny margin</li>
</ul>
<p>The project has reached an important milestone, with the release of RSQLite 1.1. This post reports the progress achieved so far, and outlines the next steps.</p>
<section id="rsqlite" class="level2">
<h2 class="anchored" data-anchor-id="rsqlite">RSQLite</h2>
<p>While the RSQLite API has changed very little (hence the minor version update), it includes a complete rewrite of the original 1.0.0 sources in C++. This has considerably simplified the code, which makes future maintenance easier, and allows us to take advantage of the more sophisticated memory management tools available in Rcpp, which help protect against memory leaks and crashes.</p>
<p>RSQLite 1.1 brings a number of improvements:</p>
<ul>
<li>New strategy for prepared queries: Create a prepared query with <code>dbSendQuery()</code> or <code>dbSendStatement()</code> and bind values with <code>dbBind()</code>. This allows you to efficiently re-execute the same query/statement with different parameter values iteratively (by calling <code>dbBind()</code> several times) or in a batch (by calling <code>dbBind()</code> once with a data-frame-like object).</li>
<li>Support for inline parametrised queries via the param argument to <code>dbSendQuery()</code>, <code>dbGetQuery()</code>, <code>dbSendStatement()</code> and <code>dbExecute()</code>, to protect from <a href="https://xkcd.com/327/">SQL injection</a>.</li>
<li>The existing methods <code>dbSendPreparedQuery()</code> and <code>dbGetPreparedQuery()</code> have been soft-deprecated, because the new API is more versatile, more consistent and stricter about parameter validation.</li>
<li>Using UTF8 for queries and parameters: this mean that non-English data should just work without any additional intervention.</li>
<li>Improved mapping between SQLite’s cell-types and R’s column-types.</li>
</ul>
<p>See the <a href="https://github.com/rstats-db/RSQLite/releases/tag/v1.1">release notes</a> for further changes.</p>
<p>The rewrite was implemented by Hadley Wickham before the “Improving DBI” project started, and has been available for a long time on GitHub. Nevertheless, the CRAN release has proven much more challenging than anticipated, because so many CRAN and Bioconductor packages import it. (Maintainers of reverse dependencies might remember multiple e-mails where I was threatening to release RSQLite “for real”.) My aim was to break as little existing code as possible. After numerous rounds of revdep-checking and improving RSQLite, I’m proud to report that the vast majority of reverse dependencies pass their checks just as well (and as quickly!) as they did with v1.0.0. Most tests from v1.0.0 are still present in the current codebase. This means that non-packaged code also has a good chance to work unchanged. I’m happy to work with package maintainers or users whose code breaks after the update.</p>
<p>DBI</p>
<hr>
<p>I have also released several DBI updates to CRAN, mostly to introduce new generics such as <code>dbBind()</code> (for parametrized/prepared queries) or <code>dbSendStatement()</code> and <code>dbExecute()</code> (for statements which don’t return data). The definition of a formal DBI specification is part of the project, a <a href="http://rstats-db.github.io/DBI/DBIspec.html">formatted version</a> is updated continuously.</p>
</section>
<section id="dbitest" class="level2">
<h2 class="anchored" data-anchor-id="dbitest">DBItest</h2>
<p>In addition to the textual specification in the DBI package, the DBItest package provides backend independent tests for DBI packages. It can be easily used by package authors to ensure that they follow the DBI specification. This is important because it allows you to take code that works with one DBI backend and easily switch to a different backend (providing that they both support the same SQL dialect). Literate programming techniques using advanced features of roxygen2 help keeping both code and textual specifications in close proximity, so that amendments to the text can be easily tracked back to changes of the test code, and vice versa.</p>
</section>
<section id="next-steps" class="level2">
<h2 class="anchored" data-anchor-id="next-steps">Next steps</h2>
<p>The rest of the project will focus on finalizing the specification in both code and text (mostly discussed on GitHub in the issue trackers for the <a href="https://github.com/rstats-db/DBI/issues">DBI</a> and <a href="https://github.com/rstats-db/DBItest/issues">DBItest</a> projects). At least one new helper package (to handle 64-bit integer types) will be created, and DBI, DBItest, and RSQLite will see yet another release: The first two will finalize the DBI specification, and RSQLite will fully conform to it.</p>
<p>The development happens entirely on GitHub in repositories of the <a href="https://github.com/rstats-db">rstats-db</a> organization. Feel free to try out development versions of the packages found there, and to report any problems or ideas at the issue trackers.</p>


</section>

 ]]></description>
  <guid>https://maelle.github.io/rdbidotorg/blog/posts/dbi-1-halfway.html</guid>
  <pubDate>Tue, 06 Dec 2016 00:00:00 GMT</pubDate>
</item>
</channel>
</rss>
